~notebook.txt

---

bp:
-.[ ] energyItems are now correctly displayed and registered
-.[ ] remain: fitness function, selectBestIndividual (or whatever)
-.[ ] bug corrected: clearreservoir()
-.[ ] senderId not complete (should be: #robot_id + #birthdate)
-.[ ] _genome vs. _currentGenome ...??? => _currentGenome seulement
-.[ ] check: genomeList contient les indivs de la gen précédente. Implement: lors de la generation ou un robot se renouvelle, il ne peut transmettre son génome. (permet de gerer le mode de mise a jour de roborobo async/random)
-.[ ] command-line: batch mode.
-.[ ] libcaca ou aalib (résolu: video_driver=dummy)
-.[ ] vitesse de rotation plus rapide? => non
-.[ ] pas le bon resetFitness dans le constructeur. résolu.
-.[ ] script python pour graphes
-.[ ] définir une region pour la position initiale des agents
-.[ ] définir une region pour la position initiale des objects
-.[ ] gGroundSensorImage_restoreOriginal: option pour permettre de remettre la valeur de la groundsensorimage a l'origine lors de réécriture (ou non, ie. du blanc). Remarque: si faux, les objets ne sont positionnables que dans les régions de pixels blancs.
-.[ ] create maze environment (use: http://www.mazegenerator.net/ )
-.[?] change name "GroundSensor" to "Footprint"
-.[+] vanillaEE: check if random selection when multiple 1st-rank
-.[-] consider Ctlrs vs. WM --> WM contains only info about robot state (no modif)
-.[=] enable include of pties files within pties file.
-.[+] MLP/Elman: tmp[j] += tanh(_weights[weightsIndice++]) * _biaisValue;
-.[=] save to PNG, added sdl2_image dependency
-.[-] unifier la méthode de rendu visuel des objets/landmarks/agents dans gScreen
-.[=] changement de la méthode de shuffle dans World::updateWorld()
-.[=] replace [s|g]etNewGenomeStatus by mapGenotypeToPhenotype() ...? => no, but added mapGenotypeToPhenotype().
-.[-] Relevance of gRefreshUserDisplay? => deleted
- [-] set up different environment for benchmark.
- [+] revoir EnergyItem (à supprimer)
- [+] supprimer gBackgroundImage...?
- [=] random=>Mersenne-Twister
- [=] putPixel32_secured vs putPixel32
- [=] CircleObject::canRegister() et registerObject: implement as robots (ie. circle, not disk)
- [+] [@Laura] cf. updateDisplay() pour faire un saveRenderScreenshot modulable (ou autre nom)
- [+] [@Theotime] Mais disons que y’a pas mal de trucs qui dépendent du timestamp même si on change la valeur par défaut, comme outputFilename et dans saveImage()
		=> search gStartTime
- [=] revoir le systeme de coordonnées pour les objets
	- integer vs real coordinates for robots (and roundObject)
	- Point2d _position.x et .y vs. _xCenterPixel et yCenterPixel;
-.[++] (@Laura) Dans la fonction performVariation(), il faut remplacer rand()/RAND_MAX par ranf().
- [=] user-control, est-ce qu'on peut qd même exécuter le controleur du robot?
- BREAKPOINT: code pour laura (saveSnapshot) en cours d'implémentation
-.[=] clean-up includes (incl.: common.h is included by roborobo.h ; use of forward declaration)
-.[=] delete CellularMap? (used?)
- [-] rename "__MyCompanyName__. All rights reserved." 
- [++] Time(NULL): pb si multiple runs in same second
	cf. http://stackoverflow.com/questions/322938/recommended-way-to-initialize-srand
- [++] CHECK: dans Makefile.modular, -lSDL2_image (oubli du "l"?)
- [=] "TemplateWanderConfigurationLoader" => (ProjectName) "TemplateWander"
- [+] /opt/local/include dans les search paths du projet (Xcode et Makefile)
- [-] Landmark.cpp/h: rename setPosition to setCoordinates
-.[=] Robot::move() - update sensors done if no collision (was: done always)
- [+] Physics
    - Robot.move() -> collision w/ objects => isPushed()
        use __recursiveIt for initial push
        isCollision returns boolean, could be: targetId
            note on multiple contacts: cf. recursive backtrak
            discriminate between other robots and objects
            note: isCollision was modified (check gMovableObjects)
        => add listCollision() (returns: list)
            used only on first iteration of Robot::move()
            returns list of all colliding objects
            used to send force to colliding objects
            (then: use isCollision to backtrack to free location)
            => OPEN-QUESTION: collides with all or with closest?
                all: simpler. One call to listCollision().
                closest: more realistic, but requires multiple calls + memory

                BREAKPOINT: debug             
                    std::cout << "[DEBUG] Moving object " << _id << " by robot " << imp.first-gRobotIndexStartOffset << " vx=" << vx << " vy=" << vy << "\n";
                    => mais afficher chgt generation

BREAKPOINT:
    wrongly multiple actions of a given robot on a particular object

---

Show the origin of selection pressure (envt vs obj) depends on the pressure to survival
- low pressure to survival: optimize objective
- high pressure to survival: optimize survival only
- by-product: pursuing an objective may be detrimental vs survival
Possible outcome: lifetime duration may ease the burden of survival in a non-linear manner 
	--> if long life, chances to encounter other even if only objective is pursued
	--> would imply transition depending on the envt pressure applied

candidates:
- popsize
- lifetime
- ...

=-=-=-=-=

revert to latest "official" commit:
 git fetch --all
 git reset --hard origin/master (change de branche, et va sur HEAD)
 git reset --hard HEAD (sur la branche courante)

=-=-=-=-=

Pour mettre les dernières modifs sur une nouvelle branche:
 git branch roborobo-movingObjects
 git checkout roborobo-movingObjects
 git commit -a -m "Work in progress"
 git push --> ou: git push --set-upstream origin roborobo-movingObjects [OPTIONNEL]

Divers:
 git branch --> affiche les branches locales
 git branch -v --> donne le dernier commit
 git branch -vv --> donne une info sur la synchro entre les branches locales et celles du serveur
 git log --oneline --graph --> donne tous les commits (lisible)

Changer de branche:
 git checkout master -- changer vers la branche master

Pour merger, depuis la branche que l'on souhaite garder:
 se positionner dans la branche à garder
 	git checkout master
 git merge <autre_branche>   (conseil: à faire avec Xcode) -- inclus un commit (pas un push)
 		=> si ecrit "fast-forward": ok, pas de merge compliqué a faire.
 git branch -d <autre_branche> (supprime la branche en local)
 aller sur github pour supprimer une vieille branche.

---

git stash {push}
git stash pop 
git stash -v

---

git remote add roborobo-theotime https://github.com/Juiblex/roborobo3
git remote -v
git fetch roborobo-theotime
git branch
git branch -v # incl. branche locale et leur head (ie. nom du dernier commit)
git branch -vv # incl. relation aux serveurs distants
git checkout -b roborobo-theotime/static-objects

Pour suivre la branche distance:
git branch --set-upstream <ma_branche_locale> roborobo-theotime/static-objects
git pull
Bien sur: pas de push possible.

